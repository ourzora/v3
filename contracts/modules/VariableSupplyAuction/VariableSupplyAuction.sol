// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.10;

import {ReentrancyGuard} from "@rari-capital/solmate/src/utils/ReentrancyGuard.sol";
import {ERC721Drop} from "./temp-MockERC721Drop.sol";

import {ERC721TransferHelper} from "../../transferHelpers/ERC721TransferHelper.sol";
import {FeePayoutSupportV1} from "../../common/FeePayoutSupport/FeePayoutSupportV1.sol";
import {ModuleNamingSupportV1} from "../../common/ModuleNamingSupport/ModuleNamingSupportV1.sol";

import {IVariableSupplyAuction} from "./IVariableSupplyAuction.sol";

/// @title Variable Supply Auction
/// @author neodaoist
/// @notice Module for variable supply, seller's choice, sealed bid auctions in ETH for ERC-721 tokens
contract VariableSupplyAuction is IVariableSupplyAuction, ReentrancyGuard, FeePayoutSupportV1, ModuleNamingSupportV1  {
    //

    /*//////////////////////////////////////////////////////////////
                        CONSTRUCTOR
    //////////////////////////////////////////////////////////////*/

    constructor(
        address _erc721TransferHelper,
        address _royaltyEngine,
        address _protocolFeeSettings,
        address _weth
    )
        FeePayoutSupportV1(_royaltyEngine, _protocolFeeSettings, _weth, ERC721TransferHelper(_erc721TransferHelper).ZMM().registrar())
        ModuleNamingSupportV1("Variable Supply Auction")
    {
        // TODO consider other approaches that keep VSA module ignorant of
        // ERC-721 Drop implementation specifics, e.g., wrapping in an
        // ERC721DropHelper which could extend BaseTransferHelper

        // erc721TransferHelper = ERC721TransferHelper(_erc721TransferHelper);
    }

    /*//////////////////////////////////////////////////////////////
                        EIP-165
    //////////////////////////////////////////////////////////////*/

    /// @notice Implements EIP-165 for standard interface detection
    /// @dev `0x01ffc9a7` is the IERC165 interface id
    /// @param _interfaceId The identifier of a given interface
    /// @return If the given interface is supported
    function supportsInterface(bytes4 _interfaceId) external pure returns (bool) {
        return _interfaceId == type(IVariableSupplyAuction).interfaceId || _interfaceId == 0x01ffc9a7;
    }

    /*//////////////////////////////////////////////////////////////
                        AUCTION STORAGE
    //////////////////////////////////////////////////////////////*/

    /// @notice The metadata for a given auction
    /// @param seller The seller of this auction
    /// @param minimumViableRevenue The minimum revenue the seller needs to generate in this auction
    /// @param sellerFundsRecipient The address where funds are sent after the auction
    /// @param startTime The unix timestamp after which the first bid can be placed
    /// @param endOfBidPhase The unix timestamp until which bids can be placed
    /// @param endOfRevealPhase The unix timestamp until which placed bids can be revealed
    /// @param endOfSettlePhase The unix timestamp until which the seller must settle the auction
    /// @param totalBalance The total balance of all sent ether for this auction
    /// @param settledRevenue The total revenue generated by the drop
    /// @param settledPricePoint The chosen price point for the drop
    /// @param settledEditionSize The resulting edition size for the drop
    struct Auction {
        address seller;
        uint96 minimumViableRevenue;
        address sellerFundsRecipient;
        uint32 startTime;
        uint32 endOfBidPhase;
        uint32 endOfRevealPhase;
        uint32 endOfSettlePhase;
        uint96 totalBalance;
        uint96 settledPricePoint;
        uint96 settledRevenue;
        uint16 settledEditionSize;
    }

    /// @notice A sealed bid
    /// @param commitmentHash The sha256 hash of the sealed bid amount concatenated with
    /// a salt string, both of which need to be included in the subsequent reveal bid tx
    /// @param bidderBalance The current bidder balance --Â before auction has been settled,
    /// this is the total amount of ether included with their bid; after auction has been
    /// settled, this is the amount of ether available for bidder to claim. More specifically,
    /// if bidder was a winner, this is the included amount of ether less the settled
    /// price point; if bidder was not a winner, this is total amount of ether originally included.
    /// @param revealedBidAmount The revealed bid amount
    struct Bid {
        bytes32 commitmentHash;
        uint96 bidderBalance;
        uint96 revealedBidAmount;
    }

    /// @notice A possible outcome if settling an auction at a given price point
    /// @param editionSize The total number of NFTs which would be minted
    /// @param revenue The amount of revenue which would be generated
    struct SettleOutcome {
        uint16 editionSize;
        uint96 revenue;
    }

    // TODO storage optimization

    /// @notice The auction for a given ERC-721 drop contract, if one exists
    /// (only one auction per token contract is allowed at one time)
    /// @dev ERC-721 token contract address => Auction    
    mapping(address => Auction) public auctionForDrop;

    /// @notice The bids which have been placed in a given Auction
    /// @dev ERC-721 token contract address => (bidder address => Bid)
    mapping(address => mapping(address => Bid)) public bidsForAuction;

    /// @notice The addresses who have placed and revealed a bid in a given auction
    /// @dev ERC-721 token contract address => all bidders who have revealed their bid
    mapping(address => address[]) internal _revealedBiddersForAuction;

    /// @notice All possible price points at which to settle an auction, based on revealed bids
    /// @dev ERC-721 token contract address => price point
    mapping(address => uint96[]) public _settlePricePointsForAuction;

    /// @notice All possible outcomes at which to settle an auction, based on revealed bids
    /// @dev ERC-721 token contract address => (price point => SettleOutcome)
    mapping(address => mapping(uint96 => SettleOutcome)) public _settleOutcomesForPricePoint;

    /*//////////////////////////////////////////////////////////////
                        CREATE AUCTION
    //////////////////////////////////////////////////////////////*/

    //     ,-.                                                                      
    //     `-'                                                                      
    //     /|\                                                                      
    //      |             ,---------------------.                                   
    //     / \            |VariableSupplyAuction|                                   
    //   Seller           `----------+----------'                                   
    //     |     createAuction()     |                                              
    //     | ----------------------->|                                              
    //     |                         |                                              
    //     |                         ----.                                          
    //     |                             | validate no existing auction for drop yet
    //     |                         <---'                                          
    //     |                         |                                              
    //     |                         ----.                                          
    //     |                             | store auction metadata                   
    //     |                         <---'                                          
    //     |                         |                                              
    //     |                         ----.                                          
    //     |                             | emit AuctionCreated()                    
    //     |                         <---'                                          
    //   Seller           ,----------+----------.                                   
    //     ,-.            |VariableSupplyAuction|                                   
    //     `-'            `---------------------'                                   
    //     /|\                                                                      
    //      |                                                                       
    //     / \                                                                                                          

    /// @notice Emitted when an auction is created
    /// @param tokenContract The address of the ERC-721 drop contract
    /// @param auction The metadata of the created auction
    event AuctionCreated(address indexed tokenContract, Auction auction);

    /// @notice Creates a variable supply auction
    /// @dev Note that a given ERC-721 drop contract can have only one live auction at a time.
    /// @param _tokenContract The address of the ERC-721 drop contract
    /// @param _minimumViableRevenue The minimum revenue the seller aims to generate in this auction --
    /// they can settle the auction below this value, but they cannot _not_ settle if the revenue
    /// generated by any price point + edition size combination would be at least this value
    /// @param _sellerFundsRecipient The address to send funds to once the auction is complete
    /// @param _startTime The Unix time that users can begin placing bids
    /// @param _bidPhaseDuration The length of time of the bid phase in seconds
    /// @param _revealPhaseDuration The length of time of the reveal phase in seconds
    /// @param _settlePhaseDuration The length of time of the settle phase in seconds
    function createAuction(
        address _tokenContract,
        uint256 _minimumViableRevenue,
        address _sellerFundsRecipient,
        uint256 _startTime,
        uint256 _bidPhaseDuration,
        uint256 _revealPhaseDuration,
        uint256 _settlePhaseDuration
    ) external nonReentrant {
        // Ensure the drop does not already have a live auction
        require(auctionForDrop[_tokenContract].startTime == 0, "ONLY_ONE_LIVE_AUCTION_PER_DROP");

        // Ensure the funds recipient is specified
        require(_sellerFundsRecipient != address(0), "INVALID_FUNDS_RECIPIENT");

        // Get the auction's storage pointer
        Auction storage auction = auctionForDrop[_tokenContract];

        // Store the associated metadata
        auction.seller = msg.sender;
        auction.minimumViableRevenue = uint96(_minimumViableRevenue);
        auction.sellerFundsRecipient = _sellerFundsRecipient;
        auction.startTime = uint32(_startTime);
        auction.endOfBidPhase = uint32(_startTime + _bidPhaseDuration);
        auction.endOfRevealPhase = uint32(_startTime + _bidPhaseDuration + _revealPhaseDuration);
        auction.endOfSettlePhase = uint32(_startTime + _bidPhaseDuration + _revealPhaseDuration + _settlePhaseDuration);

        emit AuctionCreated(_tokenContract, auction);
    }

    /*//////////////////////////////////////////////////////////////
                        CANCEL AUCTION
    //////////////////////////////////////////////////////////////*/

    //     ,-.                                                                                                               
    //     `-'                                                                                                               
    //     /|\                                                                                                               
    //      |             ,---------------------.                                                                            
    //     / \            |VariableSupplyAuction|                                                                            
    //   Seller           `----------+----------'                                                                            
    //     |     cancelAuction()     |                                                                                       
    //     | ----------------------->|                                                                                       
    //     |                         |                                                                                       
    //     |                         ----.                                                                                   
    //     |                             | validate no bids placed yet, or no settle price points meet minimum viable revenue
    //     |                         <---'                                                                                   
    //     |                         |                                                                                       
    //     |                         ----.                                                                                   
    //     |                             | emit AuctionCanceled()                                                            
    //     |                         <---'                                                                                   
    //     |                         |                                                                                       
    //     |                         ----.                                                                                   
    //     |                             | delete auction                                                                    
    //     |                         <---'                                                                                   
    //   Seller           ,----------+----------.                                                                            
    //     ,-.            |VariableSupplyAuction|                                                                            
    //     `-'            `---------------------'                                                                            
    //     /|\                                                                                                               
    //      |                                                                                                                
    //     / \                                                                                                               

    /// @notice Emitted when an auction is canceled
    /// @param tokenContract The address of the ERC-721 drop contract
    /// @param auction The metadata of the canceled auction
    event AuctionCanceled(address indexed tokenContract, Auction auction);

    /// @notice Cancels the auction for a given drop
    /// @dev An auction can only be cancelled in 2 cases -- (1) if no bids have been placed yet,
    /// or (2) if the auction is in settle phase and no price points meet minimum viable revenue.
    /// @param _tokenContract The address of the ERC-721 drop contract
    function cancelAuction(address _tokenContract) external nonReentrant {
        // Get the auction for the specified drop
        Auction memory auction = auctionForDrop[_tokenContract];

        // Ensure the auction exists
        require(auction.seller != address(0), "AUCTION_DOES_NOT_EXIST");

        // Ensure the caller is the seller
        require(msg.sender == auction.seller, "ONLY_SELLER");

        // Ensure that no bids have been placed in this auction yet, or, if in
        // settle phase, that no price points meet auction minimum viable revenue
        if (block.timestamp >= auction.endOfRevealPhase && block.timestamp < auction.endOfSettlePhase) {
            // Get the settle price points
            uint96[] storage settlePricePoints = _settlePricePointsForAuction[_tokenContract];

            // Ensure seller has first considered the settle price points before attempting to cancel
            require(settlePricePoints.length > 0, "CANNOT_CANCEL_AUCTION_BEFORE_CALCULATING_SETTLE_OPTIONS");

            // Ensure none of the price point outcomes meet minimum viable revenue
            for (uint256 i = 0; i < settlePricePoints.length; i++) {
                SettleOutcome storage settleOutcome = _settleOutcomesForPricePoint[_tokenContract][settlePricePoints[i]];
                
                require(settleOutcome.revenue < auction.minimumViableRevenue, "CANNOT_CANCEL_AUCTION_WITH_VIABLE_PRICE_POINT");
            }
        } else {
            require(auction.totalBalance == 0, "CANNOT_CANCEL_AUCTION_WITH_BIDS");        
        }

        emit AuctionCanceled(_tokenContract, auction);

        // Remove the auction from storage
        delete auctionForDrop[_tokenContract];
    }

    /*//////////////////////////////////////////////////////////////
                        PLACE BID
    //////////////////////////////////////////////////////////////*/

    //     ,-.                                                                                    
    //     `-'                                                                                    
    //     /|\                                                                                    
    //      |             ,---------------------.                                                 
    //     / \            |VariableSupplyAuction|                                                 
    //   Bidder           `----------+----------'                                                 
    //     |       placeBid()        |                                                            
    //     | ----------------------->|                                                            
    //     |                         |                                                            
    //     |                         ----.                                                        
    //     |                             | validate auction is in bid phase, and no bid placed yet
    //     |                         <---'                                                        
    //     |                         |                                                            
    //     |                         ----.                                                        
    //     |                             | update auction balance and store sealed bid            
    //     |                         <---'                                                        
    //     |                         |                                                            
    //     |                         ----.                                                        
    //     |                             | emit BidPlaced()                                       
    //     |                         <---'                                                        
    //   Bidder           ,----------+----------.                                                 
    //     ,-.            |VariableSupplyAuction|                                                 
    //     `-'            `---------------------'                                                 
    //     /|\                                                                                    
    //      |                                                                                     
    //     / \                                                                                    

    /// @notice Emitted when a bid is placed
    /// @param tokenContract The address of the ERC-721 drop contract
    /// @param bidder The address that placed a sealed bid
    /// @param auction The metadata of the auction
    event BidPlaced(address indexed tokenContract, address indexed bidder, Auction auction);

    /// @notice Places a bid in a variable supply auction
    /// @dev Note that the included ether amount must be greater than or equal to the sealed bid
    /// amount. This allows the bidder to obfuscate their true bid amount until the reveal phase.
    /// @param _tokenContract The address of the ERC-721 drop contract
    /// @param _commitmentHash The sha256 hash of the sealed bid amount concatenated with
    /// a salt string, both of which need to be included in the subsequent reveal bid tx
    function placeBid(address _tokenContract, bytes32 _commitmentHash) external payable nonReentrant {
        // Get the auction for the specified drop
        Auction storage auction = auctionForDrop[_tokenContract];

        // Ensure the auction exists
        require(auction.seller != address(0), "AUCTION_DOES_NOT_EXIST");

        // Ensure the auction is in bid phase
        require(block.timestamp < auction.endOfBidPhase, "BIDS_ONLY_ALLOWED_DURING_BID_PHASE");

        // Ensure the bidder has not placed a bid in auction already
        require(bidsForAuction[_tokenContract][msg.sender].bidderBalance == 0, "ALREADY_PLACED_BID_IN_AUCTION");

        // Ensure the bid is valid
        require(msg.value > 0 ether, "VALID_BIDS_MUST_INCLUDE_ETHER");

        // Update the total balance for auction
        auction.totalBalance += uint96(msg.value);
        
        // Store the commitment hash and included ether amount
        bidsForAuction[_tokenContract][msg.sender] = Bid({
            commitmentHash: _commitmentHash,
            bidderBalance: uint96(msg.value),
            revealedBidAmount: 0
        });

        emit BidPlaced(_tokenContract, msg.sender, auction);
    }

    /*//////////////////////////////////////////////////////////////
                        REVEAL BID
    //////////////////////////////////////////////////////////////*/

    //     ,-.                                                                                                     
    //     `-'                                                                                                     
    //     /|\                                                                                                     
    //      |             ,---------------------.                                                                  
    //     / \            |VariableSupplyAuction|                                                                  
    //   Bidder           `----------+----------'                                                                  
    //     |       revealBid()       |                                                                             
    //     | ----------------------->|                                                                             
    //     |                         |                                                                             
    //     |                         ----.                                                                         
    //     |                             | validate auction is in reveal phase, and revealed bid matches sealed bid
    //     |                         <---'                                                                         
    //     |                         |                                                                             
    //     |                         ----.                                                                         
    //     |                             | store revealed bid                                                      
    //     |                         <---'                                                                         
    //     |                         |                                                                             
    //     |                         ----.                                                                         
    //     |                             | emit BidRevealed()                                                      
    //     |                         <---'                                                                         
    //   Bidder           ,----------+----------.                                                                  
    //     ,-.            |VariableSupplyAuction|                                                                  
    //     `-'            `---------------------'                                                                  
    //     /|\                                                                                                     
    //      |                                                                                                      
    //     / \                                                                                                     

    /// @notice Emitted when a bid is revealed
    /// @param tokenContract The address of the ERC-721 drop contract
    /// @param bidder The address that placed a sealed bid
    /// @param bidAmount The revealed bid amount
    /// @param auction The metadata of the auction
    event BidRevealed(address indexed tokenContract, address indexed bidder, uint256 indexed bidAmount, Auction auction);

    /// @notice Reveals a previously placed bid
    /// @param _tokenContract The address of the ERC-721 drop contract
    /// @param _bidAmount The true bid amount
    /// @param _salt The string which was used, in combination with the true bid amount,
    /// to generate the commitment hash sent with the original placed bid tx
    function revealBid(address _tokenContract, uint256 _bidAmount, string calldata _salt) external nonReentrant {
        // Get the auction for the specified drop
        Auction storage auction = auctionForDrop[_tokenContract];

        // Ensure the auction exists
        require(auction.seller != address(0), "AUCTION_DOES_NOT_EXIST");

        // Ensure the auction is in reveal phase
        require(block.timestamp >= auction.endOfBidPhase && block.timestamp < auction.endOfRevealPhase, "REVEALS_ONLY_ALLOWED_DURING_REVEAL_PHASE");

        // Get the bid for the specified bidder
        Bid storage bid = bidsForAuction[_tokenContract][msg.sender];

        // Ensure bidder placed bid in auction
        require(bid.bidderBalance > 0 ether, "NO_PLACED_BID_FOUND_FOR_ADDRESS");

        // Ensure revealed bid amount is not greater than sent ether
        require(_bidAmount <= bid.bidderBalance, "REVEALED_BID_CANNOT_BE_GREATER_THAN_SENT_ETHER");

        // Ensure revealed bid matches sealed bid
        require(keccak256(abi.encodePacked(_bidAmount, bytes(_salt))) == bid.commitmentHash, "REVEALED_BID_DOES_NOT_MATCH_SEALED_BID");

        // Store the bidder
        _revealedBiddersForAuction[_tokenContract].push(msg.sender);

        // Store the revealed bid amount
        uint96 bidAmount = uint96(_bidAmount);
        bid.revealedBidAmount = bidAmount;

        emit BidRevealed(_tokenContract, msg.sender, _bidAmount, auction);
    }

    /*//////////////////////////////////////////////////////////////
                        SETTLE AUCTION
    //////////////////////////////////////////////////////////////*/

    //      ,-.                                                                                                                              
    //      `-'                                                                                                                              
    //      /|\                                                                                                                              
    //       |     ,---------------------.                                                            ,----------.                           
    //      / \    |VariableSupplyAuction|                                                            |ERC721Drop|                           
    //    Seller   `----------+----------'                                                            `----+-----'                           
    //      | settleAuction() |                                                                            |                                 
    //      | --------------->|                                                                            |                                 
    //      |                 |                                                                            |                                 
    //      |                 |                                                                            |                                 
    //      |___________________________________________________________________________________________   |                                 
    //      |! ALT  /  Not calculated yet?                                                              !  |                                 
    //      |!_____/          |                                                                         !  |                                 
    //      |!                ----.                                                                     !  |                                 
    //      |!                    | validate auction is in settle phase, and there are revealed bids    !  |                                 
    //      |!                <---'                                                                     !  |                                 
    //      |!                |                                                                         !  |                                 
    //      |!                ----.                                                                     !  |                                 
    //      |!                    | calculate and store possible settle outcomes                        !  |                                 
    //      |!                <---'                                                                     !  |                                 
    //      |!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!  |                                 
    //      |!~[noop]~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!  |                                 
    //      |                 |                                                                            |                                 
    //      |                 ----.                                                                        |                                 
    //      |                     | validate chosen price point meets minimum viable revenue               |                                 
    //      |                 <---'                                                                        |                                 
    //      |                 |                                                                            |                                 
    //      |                 ----.                                                                        |                                 
    //      |                     | store final price point, revenue, and edition size                     |                                 
    //      |                 <---'                                                                        |                                 
    //      |                 |                                                                            |                                 
    //      |                 ----.                                                                                                          
    //      |                     | determine winning bidders and update balances to final available refunds                                 
    //      |                 <---'                                                                                                          
    //      |                 |                                                                            |                                 
    //      |                 |                              setEditionSize()                              |                                 
    //      |                 |---------------------------------------------------------------------------->                                 
    //      |                 |                                                                            |                                 
    //      |                 |                                                                            |----.                            
    //      |                 |                                                                            |    | update drop edition size   
    //      |                 |                                                                            |<---'                            
    //      |                 |                                                                            |                                 
    //      |                 |                             adminMintAirdrop()                             |                                 
    //      |                 |---------------------------------------------------------------------------->                                 
    //      |                 |                                                                            |                                 
    //      |                 |                                                                            |----.                            
    //      |                 |                                                                            |    | mint NFT to winning bidders
    //      |                 |                                                                            |<---'                            
    //      |                 |                                                                            |                                 
    //      |                 ----.                                                                        |                                 
    //      |                     | handle seller funds recipient payout                                   |                                 
    //      |                 <---'                                                                        |                                 
    //      |                 |                                                                            |                                 
    //      |                 ----.                                                                        |                                 
    //      |                     | emit AuctionSettled()                                                  |                                 
    //      |                 <---'                                                                        |                                 
    //    Seller   ,----------+----------.                                                            ,----+-----.                           
    //      ,-.    |VariableSupplyAuction|                                                            |ERC721Drop|                           
    //      `-'    `---------------------'                                                            `----------'                           
    //      /|\                                                                                                                              
    //       |                                                                                                                               
    //      / \                                                                                                                              

    /// @notice Emitted when an auction is settled
    /// @param tokenContract The address of the ERC-721 drop contract
    /// @param auction The metadata of the created auction
    event AuctionSettled(address indexed tokenContract, Auction auction);

    /// @notice Calculate edition size and revenue for each possible price point
    /// @dev Cheaper on subsequent calls but idempotent -- after the initial call when
    /// calculations have been performed and stored, the settle outcomes will not change.
    /// Function visibility is public instead of external, to support settleAuction calling it.
    /// @param _tokenContract The address of the ERC-721 drop contract
    /// @return A tuple of 3 arrays representing the settle outcomes --
    /// the possible price points at which to settle, along with the 
    /// resulting edition sizes and amounts of revenue generated
    function calculateSettleOutcomes(address _tokenContract) public returns (uint96[] memory, uint16[] memory, uint96[] memory) {

        // TODO x improve algorithm =P

        // Get the auction for the specified drop
        Auction storage auction = auctionForDrop[_tokenContract];

        // Ensure the auction exists
        require(auction.seller != address(0), "AUCTION_DOES_NOT_EXIST");

        // Ensure the auction is in settle phase
        require(block.timestamp >= auction.endOfRevealPhase && block.timestamp < auction.endOfSettlePhase, "SETTLE_ONLY_ALLOWED_DURING_SETTLE_PHASE");

        // Get the revealed bidders for the auction
        address[] storage bidders = _revealedBiddersForAuction[_tokenContract];

        // Ensure the auction has at least 1 revealed bid
        require(bidders.length > 0, "NO_REVEALED_BIDS_TO_SETTLE_AUCTION");

        uint96[] storage settlePricePoints = _settlePricePointsForAuction[_tokenContract];
        mapping(uint96 => SettleOutcome) storage settleOutcomes = _settleOutcomesForPricePoint[_tokenContract];

        if (settlePricePoints.length == 0) { // only calculate and store once, otherwise just return from storage
            for (uint256 i = 0; i < bidders.length; i++) {
                address bidder = bidders[i];
                uint96 bidAmount = bidsForAuction[_tokenContract][bidder].revealedBidAmount;
                SettleOutcome storage settleOutcome = settleOutcomes[bidAmount];

                if (settleOutcome.editionSize == 0) {
                    settlePricePoints.push(bidAmount);
                    settleOutcome.editionSize = 1;
                }
            }

            for (uint256 j = 0; j < settlePricePoints.length; j++) {
                uint96 settlePricePoint = settlePricePoints[j];
                SettleOutcome storage settleOutcome = settleOutcomes[settlePricePoint];
                
                for (uint256 k = 0; k < bidders.length; k++) {
                    address bidder = bidders[k];
                    uint96 bidAmount = bidsForAuction[_tokenContract][bidder].revealedBidAmount;

                    if (bidAmount >= settlePricePoint) {
                        settleOutcome.editionSize++;
                        settleOutcome.revenue += settlePricePoint;
                    }
                }

                settleOutcome.editionSize--; // because 1st bidder at this settle price was double counted
            }
        }

        uint96[] memory pricePoints = new uint96[](settlePricePoints.length);
        uint16[] memory editionSizes = new uint16[](settlePricePoints.length);
        uint96[] memory revenues = new uint96[](settlePricePoints.length);

        for (uint256 m = 0; m < settlePricePoints.length; m++) {
            uint96 settlePricePoint = settlePricePoints[m];
            SettleOutcome storage settleOutcome = settleOutcomes[settlePricePoint];

            if (settleOutcome.revenue < auction.minimumViableRevenue) {
                settleOutcome.revenue = 0; // zero out, because not viable settle outcome
            }

            pricePoints[m] = settlePricePoint;
            editionSizes[m] = settleOutcome.editionSize;
            revenues[m] = settleOutcome.revenue;            
        }

        return (pricePoints, editionSizes, revenues);
    }

    /// @notice Settle an auction at a given price point
    /// @param _tokenContract The address of the ERC-721 drop contract
    /// @param _settlePricePoint The price point at which to settle the auction
    function settleAuction(address _tokenContract, uint96 _settlePricePoint) external nonReentrant {

        // TODO gas optimization
        // TODO document pragmatic max edition size / winning bidders
        // TODO consider storing winningBidders during calculateSettleOutcomes
        // TODO look for ways to consolidate business logic with calculateSettleOutcomes
        // TODO allow sellers to settle at a price point below minimum viable revenue if they so choose

        // Get the auction
        Auction storage auction = auctionForDrop[_tokenContract];

        // Calculate settle outcomes, if not done yet (also includes check for auction existence)
        if (_settlePricePointsForAuction[_tokenContract].length == 0) {
            calculateSettleOutcomes(_tokenContract);
        }

        // Get the settle outcome at this price point
        SettleOutcome storage settleOutcome = _settleOutcomesForPricePoint[_tokenContract][_settlePricePoint];
        
        // Ensure that revenue meets minimum viable revenue
        require(settleOutcome.revenue >= auction.minimumViableRevenue, "DOES_NOT_MEET_MINIMUM_VIABLE_REVENUE");

        // Store the current total balance and final auction details
        auction.totalBalance -= settleOutcome.revenue;
        auction.settledPricePoint = _settlePricePoint;
        auction.settledRevenue = settleOutcome.revenue;
        auction.settledEditionSize = settleOutcome.editionSize;

        // TODO store the fact that an auction has been settled and (1) disallow settling
        // again, (2) update endOfSettlePhase to enter cleanup phase immediately, and
        // (3) clean up unneeded storage (and allow bidders to claim refunds ASAP)

        // Get the bids for this auction
        mapping(address => Bid) storage bids = bidsForAuction[_tokenContract];

        // Get the bidders who revealed in this auction
        address[] storage bidders = _revealedBiddersForAuction[_tokenContract];

        // Loop through bids to determine winning bidders and update bidder balances
        uint256 index;
        address[] memory winningBidders = new address[](auction.settledEditionSize);   
        for (uint256 i = 0; i < bidders.length; i++) {
            // Cache the bidder
            address bidder = bidders[i];

            // Check if bid qualifies
            if (bids[bidder].revealedBidAmount >= _settlePricePoint) {
                // Mark winning bidder and increment edition size
                winningBidders[index++] = bidder;

                // Update their balance
                bids[bidder].bidderBalance -= _settlePricePoint;
            }
        }

        // Update edition size of drop
        ERC721Drop(_tokenContract).setEditionSize(uint64(auction.settledEditionSize));
        
        // Mint NFTs to winning bidders
        ERC721Drop(_tokenContract).adminMintAirdrop(winningBidders);

        // Transfer the auction revenue to the funds recipient
        _handleOutgoingTransfer(auction.sellerFundsRecipient, auction.settledRevenue, address(0), 50_000);        

        emit AuctionSettled(_tokenContract, auction);
    }

    /*//////////////////////////////////////////////////////////////
                        CLAIM REFUND
    //////////////////////////////////////////////////////////////*/

    //     ,-.                                                                                                     
    //     `-'                                                                                                     
    //     /|\                                                                                                     
    //      |             ,---------------------.                                                                  
    //     / \            |VariableSupplyAuction|                                                                  
    //   Bidder           `----------+----------'                                                                  
    //     |      claimRefund()      |                                                                             
    //     | ----------------------->|                                                                             
    //     |                         |                                                                             
    //     |                         ----.                                                                         
    //     |                             | validate auction is in cleanup phase, and bidder has an available refund
    //     |                         <---'                                                                         
    //     |                         |                                                                             
    //     |                         ----.                                                                         
    //     |                             | clear bidder available refund                                           
    //     |                         <---'                                                                         
    //     |                         |                                                                             
    //     |                         ----.                                                                         
    //     |                             | handle bidder available refund payout                                   
    //     |                         <---'                                                                         
    //     |                         |                                                                             
    //     |                         ----.                                                                         
    //     |                             | emit RefundClaimed()                                                    
    //     |                         <---'                                                                         
    //   Bidder           ,----------+----------.                                                                  
    //     ,-.            |VariableSupplyAuction|                                                                  
    //     `-'            `---------------------'                                                                  
    //     /|\                                                                                                     
    //      |                                                                                                      
    //     / \                                                                                                     

    /// @notice Emitted when a refund is claimed
    /// @param tokenContract The address of the ERC-721 drop contract
    /// @param bidder The address of the bidder claiming their refund
    /// @param refundAmount The amount of the refund claimed
    /// @param auction The metadata of the created auction
    event RefundClaimed(address indexed tokenContract, address indexed bidder, uint96 refundAmount, Auction auction);

    /// @notice Check available refund -- if a winning bidder, any additional ether sent above
    /// your bid amount; if not a winning bidder, the full amount of ether sent with your bid
    /// @param _tokenContract The address of the ERC-721 drop contract
    function checkAvailableRefund(address _tokenContract) external view returns (uint96) {
        // Get the auction
        Auction storage auction = auctionForDrop[_tokenContract];

        // Ensure the auction exists
        require(auction.seller != address(0), "AUCTION_DOES_NOT_EXIST");

        // Ensure the auction is in cleanup phase
        require(block.timestamp >= auction.endOfSettlePhase, "REFUNDS_ONLY_ALLOWED_DURING_CLEANUP_PHASE");

        // Return the balance for the specified bidder
        return bidsForAuction[_tokenContract][msg.sender].bidderBalance;
    }

    /// @notice Claim refund -- if a winning bidder, any additional ether sent above your
    /// bid amount; if not a winning bidder, the full amount of ether sent with your bid
    /// @dev Some duplicated business logic between claimRefund and checkAvailableRefund,
    /// to eliminate additional (warm) SLOADs and keep checkAvailableRefund user-friendly
    /// @param _tokenContract The address of the ERC-721 drop contract
    function claimRefund(address _tokenContract) external nonReentrant {
        // Get the auction
        Auction storage auction = auctionForDrop[_tokenContract];

        // Ensure the auction exists
        require(auction.seller != address(0), "AUCTION_DOES_NOT_EXIST");

        // Ensure the auction is in cleanup phase
        require(block.timestamp >= auction.endOfSettlePhase, "REFUNDS_ONLY_ALLOWED_DURING_CLEANUP_PHASE");

        // Get the balance for the specified bidder
        Bid storage bid = bidsForAuction[_tokenContract][msg.sender];
        uint96 bidderBalance = bid.bidderBalance;

        // Ensure bidder has a leftover balance
        require(bid.revealedBidAmount > 0 && bidderBalance > 0, "NO_REFUND_AVAILABLE");

        // Clear bidder balance
        bid.bidderBalance = 0;

        // TODO x update totalBalance and add test

        // Transfer the bidder's available refund balance to the bidder
        _handleOutgoingTransfer(msg.sender, bidderBalance, address(0), 50_000);

        emit RefundClaimed(_tokenContract, msg.sender, bidderBalance, auction);
    }

    /*//////////////////////////////////////////////////////////////
                        CLEANUP AUCTION
    //////////////////////////////////////////////////////////////*/

    // TODO consider Cleanup function to delete auction, once all refunds have been claimed
}
